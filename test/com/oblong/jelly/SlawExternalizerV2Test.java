// Copyright (c) 2010 Oblong Industries

package com.oblong.jelly;

import java.nio.ByteOrder;

import org.junit.Assert;
import static org.junit.Assert.*;
import org.junit.Test;

import static com.oblong.jelly.Slaw.*;

/**
 *  Unit Test for class SlawExternalizerV2
 *
 *
 * Created: Tue Apr 20 13:07:13 2010
 *
 * @author jao
 */
public class SlawExternalizerV2Test {
    static final SlawExternalizer externalizer = new SlawExternalizerV2();
    static final boolean LE =
        ByteOrder.LITTLE_ENDIAN == ByteOrder.nativeOrder();

    static String arrayStr(byte[] bs) {
        StringBuilder buf = new StringBuilder ("{ ");
        for (byte b : bs) buf.append(b + " ");
        buf.append("}");
        return buf.toString();
    }

    static void check(Slaw s, byte[] leb, byte[] beb, String msg) {
        final byte[] sb = externalizer.extern(s);
        final byte[] tb = LE ? leb : beb;
        String m = msg + ": " + arrayStr(sb) + " vs. " + arrayStr(tb);
        assertEquals(sb.length, externalizer.externSize(s));
        assertArrayEquals(m, tb , sb);
    }

    static void check(Slaw[] s, short[][] leb, short[][] beb) {
        for (int i = 0; i < s.length; i++) {
            byte[] lb = new byte[leb[i].length];
            byte[] bb = new byte[beb[i].length];
            for (int j = 0; j < lb.length; ++j) {
                lb[j] = (byte)leb[i][j];
                bb[j] = (byte)beb[i][j];
            }
            check(s[i], lb, bb, i + "th iteration");
        }
    }

    @Test public void nils() {
        byte[] le = {0x02, 0, 0, 0, 0, 0, 0, 0x20};
        byte[] be = {0x20, 0, 0, 0, 0, 0, 0, 0x02};
        check(nil(), le, be, "nil slaw");
    }

    @Test public void booleans() {
        short[][] ls = {{0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20},
                       {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20}};
        short[][] bs = {{0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01},
                       {0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}};
        Slaw[] sx = {bool(true), bool(false)};
        check(sx, ls, bs);
    }

    @Test public void weeStrings() {
        short[][] ls = {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x31},
                        {0x73, 0x74, 0x72, 0x30, 0x00, 0x00, 0x00, 0x35},
                        {0xE2, 0x86, 0x91, 0xE2, 0x86, 0x93, 0x00, 0x37}};
        short[][] bs = {{0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
                       {0x35,  0x00, 0x00, 0x73, 0x74, 0x72, 0x30, 0x00},
                       {0x37, 0xE2, 0x86, 0x91, 0xE2, 0x86, 0x93, 0x00}};
        Slaw[] sx = {string(""), string("str0"), string("↑↓")};
        check(sx, ls, bs);
    }

    @Test public void strings() {
        byte[] le = {0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77,
                     0x74, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20,
                     0x6e, 0x6f, 0x74, 0x20, 0x61, 0x20, 0x77, 0x65,
                     0x65, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67,
                     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
        byte[] be = le.clone();
        be[0] = le[7]; be[7] = le[0];
        check(string("this is not a wee string"), le, be, "");
    }

    @Test public void int8s() {
        short[][] le = {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80},
                        {0x96, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80},
                        {0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80}};
        short[][] be = {{0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
                        {0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x96},
                        {0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f}};
        Slaw[] sx = {int8(0), int8(-106), int8(127)};
        check(sx, le, be);
    }

    @Test public void unt8s() {
        short[][] le = {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90},
                        {0x6A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90},
                        {0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90}};
        short[][] be = {{0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
                        {0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6A},
                        {0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f}};
        Slaw[] sx = {unt8(0), unt8(106), unt8(127)};
        check(sx, le, be);
    }

    @Test public void int16s() {
        short[][] le = {{0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x84},
                        {0x00, 0x80, 0x00, 0x00, 0x00, 0x40, 0x00, 0x84},
                        {0xff, 0x7f, 0x00, 0x00, 0x00, 0x40, 0x00, 0x84}};
        short[][] be = {{0x84, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00},
                        {0x84, 0x00, 0x40, 0x00, 0x00, 0x00, 0x80, 0x00},
                        {0x84, 0x00, 0x40, 0x00, 0x00, 0x00, 0x7f, 0xff}};

        Slaw[] sx = {int16(0), int16(-32768), int16(32767)};
        check(sx, le, be);
    }
}
